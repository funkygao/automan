#!/usr/bin/php
<?php

require_once 'bootstrap.php';

/**
 * Automatically generate api doc according our customized phpdoc tags.
 *
 * Currently supported tags:
 * InputTag
 * OutputTag
 */
class Automan
{
    const SERVICE = 'Services\\';
    const URL_BASE = 'http://localhost/api/index.php';
    const VERBOSE = FALSE;
    const TESTFILE = 'test.sh';

    private function _baseClassName($filename)
    {
        return substr(basename($filename), 0, -strlen('.php'));
    }

    private function _fullQualifiedClassName($filename)
    {
        return self::SERVICE . $this->_baseClassName($filename);
    }

    private function _handleAnnotationTag($filename, Annotation $tag)
    {
        if ($tag instanceof InputTag) {
            return $this->_handleInputTag($filename, $tag);
        } elseif ($tag instanceof OutputTag) {
            return $this->_handleOutputTag($filename, $tag);
        }
    }

    private function _handleInputTag($filename, InputTag $tag)
    {
        return array(
            'input' => $tag->getJsonArray($filename),
        );

    }

    private function _handleOutputTag($filename, OutputTag $tag)
    {
        return array(
            'output' => $tag->getJsonArray($filename),
        );
    }

    private function _getApiUrl($filename, ReflectionMethod $method)
    {
        return self::URL_BASE . '?class=' . $this->_baseClassName($filename)
            . '&method=' . $method->name;
    }

    public function parsePhpFile($filename)
    {
        require_once $filename;

        $clsname = $this->_fullQualifiedClassName($filename);
        if (self::VERBOSE) {
            echo "Parsing class $clsname..." . PHP_EOL;
        }

        $ret = array(
            'filename' => $filename,
        );
        $reflection = new ReflectionClass($clsname);
        // parse each method of the controller class
        foreach ($reflection->getMethods() as $method) {
            // handle this controller action
            $p = new ReflectionAnnotatedMethod($method->class, $method->name);
            $hasTag = FALSE;
            $docs = array();
            foreach (array('InputTag', 'OutputTag') as $tagName) {
                $tag = $p->getAnnotation($tagName);
                if (!$tag) {
                    continue;
                }

                $hasTag = TRUE;
                if ($res = $this->_handleAnnotationTag($filename, $tag)) {
                    foreach ($res as $key => $val) {
                        $docs[$key] = $val;
                    }
                }
            }

            if ($hasTag) {
                $ret['api'][] = array(
                    'controller' => $this->_baseClassName($filename),
                    'action' => $method->name,
                    'url' => $this->_getApiUrl($filename, $method),
                    'io' => $docs,
                );
            }
        }

        return $ret;
    }

    public function generateTestScript($parsedResult)
    {
        foreach ($parsedResult['api'] as $api) {
            if (!is_array($api)) {
                throw Exception("invalid parsed result");
            }

            $curl = 'curl -G ' . $api['url'] . " -d '";
            foreach ($api['io']['input'] as $name => $val) {
                // TODO nested json tree
                $curl .= 'params[' . $name . ']=' . urlencode($val) . '&';
            }
            $curl .= "'";
            echo $curl . PHP_EOL;
        }
    }

    public function generateApiDoc($parsedResult)
    {

    }

}

function showHelp() {
    global $argv;
    echo "Usage: " . $argv[0] . " filename [filename]\n";
}

function main() {
    global $argv;
    ini_set('register_argc_argv', 'On');
    if (count($argv) == 1) {
        showHelp();
        exit(0);
    }

    $man = new Automan();
    foreach ($argv as $idx => $filename) {
        if ($idx == 0) {
            continue;
        }

        $result = $man->parsePhpFile($filename);
        $man->generateTestScript($result);
        $man->generateApiDoc($result);
    }
}

main();
