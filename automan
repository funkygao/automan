#!/usr/bin/php
<?php

require_once 'bootstrap.php';

/**
 * Automatically generate api doc according our customized phpdoc tags.
 *
 * Currently supported tags:
 * InputTag
 * OutputTag
 */
class Automan
{
    const SERVICE = 'Services\\';
    const URL_BASE = 'http://dw.socialgamenet.com/api/index.php';
    const VERBOSE = FALSE;
    const TESTFILE = 'test.sh';

    private function _baseClassName($filename)
    {
        return substr(basename($filename), 0, -strlen('.php'));
    }

    private function _fullQualifiedClassName($filename)
    {
        return self::SERVICE . $this->_baseClassName($filename);
    }

    private function _handleAnnotationTag($filename, Annotation $tag)
    {
        if ($tag instanceof InputTag) {
            return $this->_handleInputTag($filename, $tag);
        } elseif ($tag instanceof OutputTag) {
            return $this->_handleOutputTag($filename, $tag);
        }
    }

    private function _handleInputTag($filename, InputTag $tag)
    {
        return array(
            'input' => $tag->getJsonArray($filename),
        );

    }

    private function _handleOutputTag($filename, OutputTag $tag)
    {
        return array(
            'output' => $tag->getJsonArray($filename),
        );
    }

    private function _normalizedController($baseClassname) 
    {
        $slot = strlen('Service');
        if (substr($baseClassname, -$slot) === 'Service') {
            return substr($baseClassname, 0, -$slot);
        }
        return $baseClassname;
    }

    private function _getApiUrl($filename, ReflectionMethod $method)
    {
        return self::URL_BASE;
    }

    public function parsePhpFile($filename)
    {
        require_once $filename;

        $clsname = $this->_fullQualifiedClassName($filename);
        if (self::VERBOSE) {
            echo "Parsing class $clsname..." . PHP_EOL;
        }

        $ret = array(
            'filename' => $filename,
        );
        $reflection = new ReflectionClass($clsname);
        // parse each method of the controller class
        foreach ($reflection->getMethods() as $method) {
            // handle this controller action
            $p = new ReflectionAnnotatedMethod($method->class, $method->name);
            $hasTag = FALSE;
            $inputOutput = array();
            foreach (array('InputTag', 'OutputTag') as $tagName) {
                $tag = $p->getAnnotation($tagName);
                if (!$tag) {
                    continue;
                }

                $hasTag = TRUE;
                if ($res = $this->_handleAnnotationTag($filename, $tag)) {
                    foreach ($res as $key => $val) {
                        $inputOutput[$key] = $val;
                    }
                }
            }

            if ($hasTag) {
                $controller = $this->_normalizedController($this->_baseClassName($filename));
                $ret['api'][] = array(
                    'controller' => $controller,
                    'action' => $method->name,
                    'url' => $this->_getApiUrl($filename, $method),
                    'io' => $inputOutput,
                );
            }
        }

        return $ret;
    }

    public function generateTestScript($parsedResult)
    {
        foreach ($parsedResult['api'] as $api) {
            if (!is_array($api)) {
                throw Exception("invalid parsed result");
            }

            print_r($api);

            if (!empty($api['io']['input'])) {
                $curl = 'curl -G ' . $api['url'] . " -d '";
                $curl .= 'class=' . $api['controller'];
                $curl .= '&method=' . $api['action'];
                foreach ($api['io']['input'] as $name => $val) {
                    // TODO nested json tree
                    $curl .= '&params[' . $name . ']=' . urlencode($val);
                }
                $curl .= "'";
                echo $curl . PHP_EOL;
            }
        }
    }

    public function generateApiDoc($parsedResult)
    {
        foreach ($parsedResult['api'] as $api) {
            if (!is_array($api)) {
                throw Exception("invalid parsed result");
            }

            echo str_repeat("=", 80) . PHP_EOL;
            echo "\t\t" . $api['controller'] . ":" . $api['action'] . PHP_EOL;
            echo str_repeat("=", 80) . PHP_EOL;
            if (!empty($api['io']['input'])) {
                echo str_repeat('=>', 10) . " Input " . PHP_EOL;
                print_r($api['io']['input']);
            }
            if (!empty($api['io']['output'])) {
                echo str_repeat('<=', 10) . " Output " . PHP_EOL;
                print_r($api['io']['output']);
            }

            echo PHP_EOL;
        }
    }

    public function generateWebServerConfig($parsedResult)
    {

    }

}

function showHelp() {
    global $argv;
    echo "Usage: " . $argv[0] . " filename [filename]\n";
}

function main() {
    global $argv;
    ini_set('register_argc_argv', 'On');
    if (count($argv) == 1) {
        showHelp();
        exit(0);
    }

    $man = new Automan();
    foreach ($argv as $idx => $filename) {
        if ($idx == 0) {
            continue;
        }

        $result = $man->parsePhpFile($filename);
        $man->generateTestScript($result);
        $man->generateApiDoc($result);
        $man->generateWebServerConfig($result);
    }
}

main();
